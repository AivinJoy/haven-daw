old-file// src/main.rs

use crossterm::{
    event::{self, Event, KeyCode, KeyEventKind, KeyModifiers},
    terminal::{disable_raw_mode, enable_raw_mode},
};
use std::io::{stdout, Write};
use std::path::PathBuf;
use std::time::Duration;

use daw_modules::{AudioPlayer, Recorder};

use daw_modules::daw_controller::{DawController, DawMode};

// -------------------------------------------------------------
// Helper: Format time as mm:ss
// -------------------------------------------------------------
fn format_duration(d: Duration) -> String {
    let secs = d.as_secs();
    format!("{:02}:{:02}", secs / 60, secs % 60)
}

// -------------------------------------------------------------
// UI Update
// -------------------------------------------------------------
fn update_ui(player: &AudioPlayer, recorder: &Option<Recorder>, total_str: &str) {
    let curr = player.get_current_time();
    let curr_str = format_duration(curr);

    let rec_str = if let Some(r) = recorder {
        let rt = r.get_record_time();
        let rt_str = format_duration(rt);
        format!(" ðŸ”´ REC {}", rt_str)
    } else {
        String::new()
    };

    print!("\rðŸŽµ Time: {} / {}{}", curr_str, total_str, rec_str);
    let _ = stdout().flush();
}


fn render_live_waveform(recorder: &Option<Recorder>) {
    use daw_modules::waveform::terminal::render_ascii;

    if let Some(rec) = recorder {
        let wf = rec.live_waveform();
        if let Ok(wf_guard) = wf.lock() {
            let (mins, maxs) = wf_guard.snapshot();
            let cols = 120;
            if !mins.is_empty() {
                let len = mins.len();
                let start = len.saturating_sub(cols);
                let ascii = render_ascii(&mins[start..], &maxs[start..], 20);

                // Move cursor up to overwrite previous waveform
                print!("\x1B[{}A", ascii.len() + 1);

                // Print the waveform
                for line in ascii {
                    println!("{line}");
                }
            }
        }
    }
}



// -------------------------------------------------------------
// Handle SPACE â†’ Play/Pause
// -------------------------------------------------------------
fn handle_playback_keys(player: &AudioPlayer, key: &KeyCode) {
    if matches!(key, KeyCode::Char(' ')) {
        player.toggle_playback();
    }
}

// -------------------------------------------------------------
// Handle Up/Down â†’ Volume
// -------------------------------------------------------------
fn handle_volume_keys(player: &AudioPlayer, key: &KeyCode) {
    match key {
        KeyCode::Up => {
            let new = (player.get_volume() + 0.1).min(1.0);
            player.set_volume(new);
        }
        KeyCode::Down => {
            let new = (player.get_volume() - 0.1).max(0.0);
            player.set_volume(new);
        }
        _ => {}
    }
}

// -------------------------------------------------------------
// Handle Left/Right â†’ Seeking
// -------------------------------------------------------------
fn handle_seek_keys(player: &AudioPlayer, key: &KeyCode, modifiers: KeyModifiers) {
    let step = if modifiers.contains(KeyModifiers::CONTROL) {
        10
    } else if modifiers.contains(KeyModifiers::SHIFT) {
        1
    } else {
        5
    };

    match key {
        KeyCode::Right => {
            let _ = player.seek_by_secs(step);
        }
        KeyCode::Left => {
            let _ = player.seek_by_secs(-step);
        }
        _ => {}
    }
}

// -------------------------------------------------------------
// Handle R â†’ Start/Stop Recording
// -------------------------------------------------------------
fn handle_recording_keys(
    recorder: &mut Option<Recorder>,
    key: &KeyCode,
) {
    match key {
        KeyCode::Char('r') | KeyCode::Char('R') => {
            if recorder.is_none() {
                let path = PathBuf::from("recording.wav");

                match Recorder::start(path) {      // <--- no sample_rate argument
                    Ok(r) => {
                        *recorder = Some(r);
                        println!("\nðŸ”´ Recording started: recording.wav");
                    }
                    Err(e) => println!("\nâŒ Failed to start recording: {}", e),
                }
            } else {
                if let Some(r) = recorder.take() {
                    r.stop();
                    println!("\nâ¹ï¸  Recording stopped and saved.");
                }
            }
        }
        _ => {}
    }
}


// NEW: Handle L â†’ toggle monitoring while recording
fn handle_monitor_keys(recorder: &mut Option<Recorder>, key: &KeyCode) {
    if matches!(key, KeyCode::Char('l') | KeyCode::Char('L')) {
        if let Some(rec) = recorder.as_mut() {
            if let Err(e) = rec.toggle_monitor() {
                println!("\nâŒ Failed to toggle monitor: {}", e);
            }
        } else {
            // Not recording -> ignore
        }
    }
}


// -------------------------------------------------------------
// Handle Q / Ctrl+C â†’ Quit
// -------------------------------------------------------------
fn should_quit(key: &KeyCode, modifiers: KeyModifiers) -> bool {
    matches!(key, KeyCode::Char('q') | KeyCode::Char('Q'))
        || (*key == KeyCode::Char('c') && modifiers.contains(KeyModifiers::CONTROL))
}

// -------------------------------------------------------------
// MAIN
// -------------------------------------------------------------
fn main() -> Result<(), anyhow::Error> {
    // ------------------------------------------
    // Load file from CLI
    // ------------------------------------------
    let path = std::env::args()
        .nth(1)
        .expect("Expected a path to an audio file as argument.");

    // ------------------------------------------
    // Waveform â†’ ASCII print
    // ------------------------------------------
    let wf = daw_modules::Waveform::build_from_path(&path, 512)?;
    let spp = (wf.sample_rate as f64) / 60.0;
    let (mins, maxs, _lvl) = wf.bins_for(spp, 0, 0, 120);
    let ascii = daw_modules::waveform::terminal::render_ascii(mins, maxs, 20);
    for line in ascii {
        println!("{line}");
    }

    // ------------------------------------------
    // Audio Player
    // ------------------------------------------
    let player = AudioPlayer::new(&path)?;
    let total_time = player.get_total_duration();
    let total_time_str = format_duration(total_time);

    // ------------------------------------------
    // Recorder state
    // ------------------------------------------
    let mut recorder: Option<Recorder> = None;
    // let output_sample_rate = 44100;

    println!("Press [SPACE] Play/Pause | [UP/DOWN] Volume | [R] Record | [Q] Quit");

    // ------------------------------------------
    // MAIN LOOP
    // ------------------------------------------
    enable_raw_mode()?;

    loop {
        update_ui(&player, &recorder, &total_time_str);

        render_live_waveform(&recorder);

        // Stop when song ends
        if player.is_playing() && player.get_current_time() >= total_time {
            println!("\nSong finished.");
            break;
        }

        // Poll keys every 50 ms
        if event::poll(Duration::from_millis(50))? {
            if let Event::Key(ev) = event::read()? {
                if ev.kind == KeyEventKind::Press {
                    let key = ev.code;

                    handle_playback_keys(&player, &key);
                    handle_volume_keys(&player, &key);
                    handle_seek_keys(&player, &key, ev.modifiers);
                    handle_recording_keys(&mut recorder, &key);
                    handle_monitor_keys(&mut recorder, &key); 

                    if should_quit(&key, ev.modifiers) {
                        println!("\rðŸ›‘ Quitting...");
                        break;
                    }
                }
            }
        }
    }

    // ------------------------------------------
    // Cleanup
    // ------------------------------------------
    if let Some(r) = recorder {
        r.stop();
    }

    disable_raw_mode()?;
    Ok(())
}
