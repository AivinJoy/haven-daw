// src/decoder.rs

use anyhow::anyhow;
use ringbuf::traits::Producer as RbProducer;
use rubato::{
    calculate_cutoff, Resampler, SincFixedIn, SincInterpolationParameters,
    SincInterpolationType, WindowFunction,
};
use std::fs::File;
use std::sync::{
    atomic::{AtomicBool, Ordering},
    mpsc::{channel, Receiver, Sender},
    Arc,
};
use std::thread::{self, JoinHandle};
use std::time::Duration;
use symphonia::core::audio::{AudioBufferRef, SampleBuffer};
use symphonia::core::codecs::DecoderOptions;
use symphonia::core::errors::Error as SymphoniaError;
use symphonia::core::formats::FormatOptions;
use symphonia::core::io::MediaSourceStream;
use symphonia::core::meta::MetadataOptions;
use symphonia::default::{get_codecs, get_probe};

/// Control commands for the decoder thread.
pub enum DecoderCmd {
    Seek(Duration),
}

/// Struct-based decoder: Symphonia decode -> channel mix -> optional rubato resample
/// -> interleaved f32 pushed to ring buffer.
pub struct Decoder<P>
where
    P: RbProducer<Item = f32> + Send + 'static,
{
    path: String,
    producer: P,
    is_playing: Arc<AtomicBool>,
    output_channels: usize,
    source_sample_rate: u32,
    output_sample_rate: u32,
    cmd_rx: Receiver<DecoderCmd>,
    // Post-seek de-click: fade-in N samples after next seek.
    post_seek_fade_samples: usize,
}

impl<P> Decoder<P>
where
    P: RbProducer<Item = f32> + Send + 'static,
{
    pub fn new_with_ctrl(
        path: String,
        producer: P,
        is_playing: Arc<AtomicBool>,
        _source_channels: usize, // kept for compatibility; actual decoded channels are read from packets
        output_channels: usize,
        source_sample_rate: u32,
        output_sample_rate: u32,
        cmd_rx: Receiver<DecoderCmd>,
    ) -> Self {
        Self {
            path,
            producer,
            is_playing,
            output_channels,
            source_sample_rate,
            output_sample_rate,
            cmd_rx,
            post_seek_fade_samples: 0,
        }
    }

    pub fn spawn(self) -> JoinHandle<()> {
        thread::spawn(move || {
            if let Err(e) = self.run() {
                eprintln!("Decoder thread error: {e}");
            }
        })
    }

    fn run(mut self) -> Result<(), anyhow::Error> {
        // Open and probe the input file (Symphonia).
        let file = File::open(&self.path)?;
        let mss = MediaSourceStream::new(Box::new(file), Default::default());
        let probed = get_probe().format(
            &Default::default(),
            mss,
            &FormatOptions::default(),
            &MetadataOptions::default(),
        )?;
        let mut format = probed.format;

        let track = format
            .default_track()
            .ok_or_else(|| anyhow!("no default audio track"))?;
        let track_id = track.id;

        let mut decoder = get_codecs().make(&track.codec_params, &DecoderOptions::default())?;

        // Lazily allocated interleaved f32 buffer.
        let mut sample_buf: Option<SampleBuffer<f32>> = None;

        // Optional resampler, initialized once, using robust defaults.
        let need_resample = self.source_sample_rate != self.output_sample_rate;

        let sinc_len = 256usize;
        let window = WindowFunction::BlackmanHarris2;
        let f_cutoff = calculate_cutoff(sinc_len, window);
        let oversampling = 128; // balance CPU and quality.

        let mut resampler = if need_resample {
            let ratio = self.output_sample_rate as f64 / self.source_sample_rate as f64;
            let params = SincInterpolationParameters {
                sinc_len,
                f_cutoff,
                interpolation: SincInterpolationType::Linear,
                oversampling_factor: oversampling,
                window,
            };
            let chunk_size = 1024;
            Some(SincFixedIn::<f32>::new(
                ratio,
                2.0,
                params,
                chunk_size,
                self.output_channels,
            )?)
        } else {
            None
        };

        // Staging buffer for rubato input (planar).
        let mut stage_planar: Vec<Vec<f32>> = vec![Vec::with_capacity(4096); self.output_channels];

        // Decode loop.
        loop {
            // Handle any pending control commands non-blockingly.
            while let Ok(cmd) = self.cmd_rx.try_recv() {
                match cmd {
                    DecoderCmd::Seek(target) => {
                        // Build Time from Duration and perform an accurate seek.
                        let track = format
                            .default_track()
                            .ok_or_else(|| anyhow!("no default track during seek"))?;
                        let seconds = target.as_secs();
                        let frac = target.subsec_nanos() as f64 / 1_000_000_000f64;
                        let time = symphonia::core::units::Time::new(seconds, frac);
                        format.seek(
                            symphonia::core::formats::SeekMode::Accurate,
                            symphonia::core::formats::SeekTo::Time {
                                time,
                                track_id: Some(track.id),
                            },
                        )?;

                        // Reset transient state after seek.
                        sample_buf = None;
                        for ch in &mut stage_planar {
                            ch.clear();
                        }
                        if let Some(r) = &mut resampler {
                            r.reset();
                        }

                        // Enable a short fade-in (10 ms) to de-click.
                        self.post_seek_fade_samples =
                            (self.output_sample_rate as usize / 100) * self.output_channels;
                    }
                }
            }

            let packet = match format.next_packet() {
                Ok(p) => p,
                Err(SymphoniaError::ResetRequired) => {
                    // Simple player: stop on chained stream reset; a full player could re-probe here.
                    break;
                }
                Err(_) => break,
            };

            if packet.track_id() != track_id {
                continue;
            }

            match decoder.decode(&packet) {
                Ok(decoded) => {
                    // Use actual decoded channel count every time.
                    let decoded_ch = decoded.spec().channels.count();

                    // Allocate interleaved f32 buffer on first decode.
                    if sample_buf.is_none() {
                        let capacity = decoded.capacity() as u64;
                        sample_buf = Some(SampleBuffer::<f32>::new(capacity, *decoded.spec()));
                    }

                    let buf = sample_buf.as_mut().unwrap();
                    // Copy decoded audio into interleaved f32.
                    copy_interleaved_into_f32(buf, decoded);
                    let src_interleaved = buf.samples();

                    // Mix to output layout first so resampler runs on final channel count.
                    if let Some(resampler) = &mut resampler {
                        // Mixed interleaved into planar staging, then feed resampler.
                        if decoded_ch == self.output_channels {
                            append_interleaved_to_planar(
                                src_interleaved,
                                &mut stage_planar,
                                self.output_channels,
                            );
                        } else {
                            let mixed_interleaved = updown_mix_interleaved(
                                src_interleaved,
                                decoded_ch,
                                self.output_channels,
                            );
                            append_interleaved_to_planar(
                                &mixed_interleaved,
                                &mut stage_planar,
                                self.output_channels,
                            );
                        }

                        // Feed exactly the requested frames; for quicker first sound after a seek,
                        // consider allowing one partial block via process_partial(Some(...)) here.
                        loop {
                            let need = resampler.input_frames_next();
                            let have = planar_len(&stage_planar);
                            if have < need {
                                break;
                            }

                            let in_block = take_from_planar(&mut stage_planar, need);
                            let mut out_block = resampler.process(&in_block, None)?;
                            let interleaved_out = interleave(&mut out_block);
                            self.write_interleaved(&interleaved_out);
                        }
                    } else {
                        // No resampling: write interleaved directly, mixing only if needed.
                        if decoded_ch == self.output_channels {
                            self.write_interleaved(src_interleaved);
                        } else {
                            let mixed_interleaved = updown_mix_interleaved(
                                src_interleaved,
                                decoded_ch,
                                self.output_channels,
                            );
                            self.write_interleaved(&mixed_interleaved);
                        }
                    }
                }
                Err(SymphoniaError::IoError(_)) => continue,
                Err(SymphoniaError::DecodeError(_)) => continue,
                Err(_) => break,
            }

            self.yield_if_paused();
        }

        // Drain remaining frames from resampler to avoid truncation artifacts.
        if let Some(resampler) = &mut resampler {
            let have = planar_len(&stage_planar);
            if have > 0 {
                let in_block = take_from_planar(&mut stage_planar, have);
                let mut out_block = resampler.process_partial(Some(&in_block), None)?;
                let interleaved_out = interleave(&mut out_block);
                self.write_interleaved(&interleaved_out);
            }
            let mut out_block = resampler.process_partial::<Vec<f32>>(None, None)?;
            if !out_block.is_empty() && !out_block[0].is_empty() {
                let interleaved_out = interleave(&mut out_block);
                self.write_interleaved(&interleaved_out);
            }
        }

        Ok(())
    }

    #[inline]
    fn write_interleaved(&mut self, data: &[f32]) {
        // Apply post-seek fade-in if active.
        let mut idx = 0usize;

        if self.post_seek_fade_samples > 0 && idx < data.len() {
            let remain = self.post_seek_fade_samples.min(data.len() - idx);
            for i in 0..remain {
                let ramp = (i as f32) / (remain as f32);
                let s = data[idx + i] * ramp;
                loop {
                    match self.producer.try_push(s) {
                        Ok(()) => break,
                        Err(_) => std::thread::park_timeout(Duration::from_micros(200)),
                    }
                }
            }
            self.post_seek_fade_samples -= remain;
            idx += remain;
        }

        // Attempt to push remaining samples with small parks on backpressure.
        while idx < data.len() {
            match self.producer.try_push(data[idx]) {
                Ok(()) => idx += 1,
                Err(_) => {
                    // Short park to reduce CPU when back-pressured without hurting latency.
                    std::thread::park_timeout(Duration::from_micros(200));
                }
            }
        }
    }

    #[inline]
    fn yield_if_paused(&self) {
        if !self.is_playing.load(Ordering::Relaxed) {
            // Slightly longer sleep when paused to cut CPU while idle.
            thread::sleep(Duration::from_millis(10));
        }
    }
}

/// Backwards-compatible wrapper returning JoinHandle and a control Sender.
/// Prefer this from player.rs to enable seeking.
pub fn spawn_decoder_with_ctrl<P>(
    path: String,
    producer: P,
    is_playing: Arc<AtomicBool>,
    source_channels: usize,
    output_channels: usize,
    source_sample_rate: u32,
    output_sample_rate: u32,
) -> (JoinHandle<()>, Sender<DecoderCmd>)
where
    P: RbProducer<Item = f32> + Send + 'static,
{
    let (tx, rx) = channel();
    let handle = Decoder::new_with_ctrl(
        path,
        producer,
        is_playing,
        source_channels,
        output_channels,
        source_sample_rate,
        output_sample_rate,
        rx,
    )
    .spawn();
    (handle, tx)
}

/// Legacy wrapper (no seek). Kept so existing code still compiles.
#[allow(dead_code)]
pub fn spawn_decoder<P>(
    path: String,
    producer: P,
    is_playing: Arc<AtomicBool>,
    source_channels: usize,
    output_channels: usize,
    source_sample_rate: u32,
    output_sample_rate: u32,
) -> JoinHandle<()>
where
    P: RbProducer<Item = f32> + Send + 'static,
{
    let (handle, _tx) = spawn_decoder_with_ctrl(
        path,
        producer,
        is_playing,
        source_channels,
        output_channels,
        source_sample_rate,
        output_sample_rate,
    );
    handle
}

// ---- Helpers ----

fn copy_interleaved_into_f32(dst: &mut SampleBuffer<f32>, src: AudioBufferRef<'_>) {
    dst.copy_interleaved_ref(src);
}

fn append_interleaved_to_planar(
    interleaved: &[f32],
    planar: &mut [Vec<f32>],
    channels: usize,
) {
    let frames = interleaved.len() / channels;
    for f in 0..frames {
        let row = &interleaved[f * channels..(f + 1) * channels];
        for ch in 0..channels {
            planar[ch].push(row[ch]);
        }
    }
}

fn planar_len(planar: &[Vec<f32>]) -> usize {
    planar.iter().map(|v| v.len()).min().unwrap_or(0)
}

fn take_from_planar(planar: &mut [Vec<f32>], frames: usize) -> Vec<Vec<f32>> {
    let channels = planar.len();
    let mut out = Vec::with_capacity(channels);
    for ch in 0..channels {
        let n = frames.min(planar[ch].len());
        let tail = planar[ch].split_off(n);
        let head = std::mem::replace(&mut planar[ch], tail);
        out.push(head);
    }
    out
}

fn interleave(planar: &mut [Vec<f32>]) -> Vec<f32> {
    let channels = planar.len();
    if channels == 0 {
        return Vec::new();
    }
    let frames = planar[0].len();
    let mut out = vec![0.0f32; frames * channels];
    for f in 0..frames {
        for ch in 0..channels {
            out[f * channels + ch] = planar[ch][f];
        }
    }
    out
}

fn updown_mix_interleaved(input: &[f32], in_ch: usize, out_ch: usize) -> Vec<f32> {
    if in_ch == out_ch {
        return input.to_vec();
    }
    let frames = input.len() / in_ch;
    let mut out = vec![0.0f32; frames * out_ch];

    match (in_ch, out_ch) {
        (1, 2) => {
            for f in 0..frames {
                let m = input[f];
                out[f * 2] = m;
                out[f * 2 + 1] = m;
            }
        }
        (2, 1) => {
            for f in 0..frames {
                let l = input[f * 2];
                let r = input[f * 2 + 1];
                out[f] = 0.5 * (l + r);
            }
        }
        _ if out_ch < in_ch => {
            let factor = in_ch as f32 / out_ch as f32;
            for f in 0..frames {
                for oc in 0..out_ch {
                    let start = (oc as f32 * factor).floor() as usize;
                    let end = (((oc + 1) as f32 * factor).ceil() as usize).min(in_ch);
                    let mut acc = 0.0f32;
                    let mut n = 0usize;
                    for ic in start..end {
                        acc += input[f * in_ch + ic];
                        n += 1;
                    }
                    out[f * out_ch + oc] = if n > 0 { acc / n as f32 } else { 0.0 };
                }
            }
        }
        _ => {
            for f in 0..frames {
                for oc in 0..out_ch {
                    let ic = oc % in_ch;
                    out[f * out_ch + oc] = input[f * in_ch + ic];
                }
            }
        }
    }

    out
}
